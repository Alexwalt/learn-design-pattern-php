去除程序对全局变量以来，单例模式是的存储的数据全局可用
为什么要使用单例？
例存在哪些问题？
单例与静态类的区别？
有何替代的解决方案？
现代的PHP是一门非常适合用来学习设计模式的脚本语言，为什么这样说，因为像Java一样支持抽象类、接口类，支持了这两个属性，就可以更方便的学习设计模式了

1 处理资源访问冲突、解决资源竞争，例如写日志功能，如果new出多个实例，同时写入一个文件，就可能造成文件中内容的覆盖
2 表示全局唯一，某些数据在系统中只能保存一份，比如配置信息类、唯一ID发号器
尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。

如何实现一个单例？
概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：
- 构造函数需要是 private 访问权限的
- 这样才能避免外部通过 new 创建实例
- 考虑对象创建时的线程安全问题
- 考虑是否支持延迟加载
- 考虑 getInstance() 性能是否高（是否加锁）。


1. 饿汉式饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例）
2. 懒汉式有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：2. 懒汉式有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：
3. 双重检测饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。
4. 静态内部类我们再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式    ，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现。

1. 单例的定义单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。
2. 单例的用处从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。