简单工厂
# 定义
提供一个创建实例对象实例的功能，而无需关心具体实现。被创建的实例可以是接口、抽象类，也可以是具体类。

# 理解

其实工厂模式主要就是根据输入的类型（`type`）生成指定的对象(`object`)，封装对象的创建过程，将对象的创建和使用相分离。
在获取对象的过程中，会存在大量的`if-else`，这些`if-else`大量侵入业务代码，就成了有坏味道的代码，对后期的阅读和维护是十分不利的，那么把这一坨	`if-else`放入到工厂类中，业务代码调用工厂来获取相应的实例，如果后期增加新的产品，只需要重新添加产品类，然后在工厂里加入类型判断即可。如果真的想消除分支语句，可以使用查表法来干掉烦人的`if-else`

- 转移`if-esle`语句到工厂类中
- 相对于直接 new 来创建对象，使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。


# 适合场景
什么情况下适合使用简单工程？

1. 类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。
2. 尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。
# 作用
在上升一个思维层面来看工厂模式后，它的作用有下面这四个（**判断是否使用工厂模式**的最本质的**参考标准**）
1. 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
2. 代码复用：创建代码抽离到独立的工厂类之后可以复用。
3. 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
4. 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

# 案例需求描述

我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），~~将存储在文件中的配置解析成内存对象 RuleConfig~~ 。

## 方法一（转移`if-else`）
运行方式
```bash
$ php client.php
```