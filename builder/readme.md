# 定义
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
建造者模式也被称之为构建者模式、生成器模式




# 适用场景
生成器模式的主要解决的问题是批量设置初始值和检验参数，如果有这两个需求，建造者模式就有用武之地了。

如果存在下面情况中的任意一种，我们就可以使用建造者模式了：

- 我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 `set()` 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。
- 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 `set()` 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。
- 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 `set()` 方法。构造函数配合 `set()` 方法来设置属性值的方式就不适用了。







# 需求描述
我们需要定义一个资源池配置类 `ResourcePoolConfig`。这里的资源池，你可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 `ResourcePoolConfig` 类。
成员变量     | 解释|是否必填|默认值
-------- | -----| -----| -----
name  | 资源名称|是|没有
maxTotal| 最大总资源数量|否|8
maxIdle|最大空闲资源数量 |否|8
minIdle|最小空闲资源数量|否|0

# 编码思路
我们可以把校验逻辑放置到 `Builder` 类中，先创建建造者，并且通过 `set()` 方法设置建造者的变量值，然后在使用 `build()` 方法真正创建对象之前做集中的校验，校验通过之后才会创建对象。并且，`ResourcePoolConfig` 没有提供任何 `set()` 方法，这样我们创建出来的对象就是不可变对象了。

# 有趣例子
顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如有披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。
# 总结
如果构造函数参数过多，考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。

参考资料：
[1]. [极客时间《设计模式》（王争）](http://gk.link/a/10xlp)
[2].《[研磨设计模式》（陈臣、王斌）](https://book.douban.com/subject/5343318/)
[3]. [《Learning PHP设计模式》](https://book.douban.com/subject/25952240/)
[4]. [从零使用composer初始化PSR-4项目](https://blog.csdn.net/hl449006540/article/details/119188623)
[5]. [https://learnku.com/docs/php-design-patterns/2018/Builder/1488](https://learnku.com/docs/php-design-patterns/2018/Builder/1488)
[6]. [https://www.cnblogs.com/sunshine-H/p/8268553.html](https://www.cnblogs.com/sunshine-H/p/8268553.html)